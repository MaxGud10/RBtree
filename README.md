# RED-BLACK_TREE

Проект создан в рамках курса по $C$++ Константина Владимирова.
Задача состояла в том, чтобы реализовать класс, представляющий собой сбалансированное дерево, которое находит k-й наименьший элемент (K-query) и количество элементов, меньшее заданного (N-query), за `O(log n)` времени.

## Опискание

Красно-чёрное дерево — двоичное дерево поиска, у которого каждому узлу сопоставлен дополнительный атрибут - цвет и для которого выполняются следубщие свойства:
- Каждый узел промаркирован красным или черным цветом. 
- Корень и конечные узлы (листья) дерева - черные. 
- У красного узла родительский узел - черный.
- Все простые пути из любого узла x до листьев содержат одинаковое количество черных узлов.

Все листья дерева являются фиктивными и не содеражат данных, но относятся к дереву и являются чёрными. 



# Описание проекта 

## Ввод
- Программа получает ключи и запросы от стандартных входных данных.
- Каждый запрос состоит из пары ключей (два возможных значения).
- Запрос действителен только в том случае, если второй ключ больше, чем первый; в противном случае результат для этого запроса равен нулю.


## Вывод
Для каждого запроса программа должна учитывать количество ключей в дереве, которые лежат строго в левой и правой границах запроса (включительно).

### Пример
```bash
k 10
k 20
k 15
q 10 20
```

Вывод
```bash
3
```

# Создание проекта


## Режимы работы

 проекте реализовано несколько режимов, включаемых через параметры **CMake**.

| Режим | Флаги CMake | Назначение |
|:------|:-------------|:-----------|
| **Основной режим** (по умолчанию) | `-DSET_MODE_ENABLED=OFF` | Работает только дерево, выводит ответы. |
| **Проверки** | `-DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=VERIFY` | Дополнительно сверяет ответы с `std::set`, выводит расхождения в `stderr`. |
| **Замера времени** | `-DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=BENCH` | Измеряет время выполнения операций для дерева и `std::set` и выводит сводку. |
| **Debug* | `-DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=DEBUG -DCMAKE_BUILD_TYPE=Debug` | После выполнения создаёт графическое представление дерева (`graphviz/tree_graph.png`). |

-----------------------------------------

### Зависимости

- Компилятор, совместимый с C++17.
- CMake (минимальная версия 3.11).
- Установлен Graphviz (команда `dot`).


### Запуск проекта 

```bash
git clone https://github.com/MaxGud10/RBtree
cd RBtree
mkdir build
```

 - `Основной режимy`
 ```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DSET_MODE_ENABLED=OFF
cmake --build build
./build/rb_tree.out < tests/end2end/small_input.tx

```

- `Режим проверки`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=VERIFY
cmake --build build
./build/rb_tree.out < tests/end2end/small_input.txt

```
При несовпадении результатов дерево постороенное через `set` выведет отладочную информацию в `stderr`.


- `Режим замера времени`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=BENCH
cmake --build build
./build/rb_tree.out < tests/end2end/big_input.txt 1>/dev/null
```

- `Debug`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DSET_MODE_ENABLED=ON -DCUSTOM_SET_VALUE=DEBUG
cmake --build build
./build/rb_tree.out < tests/end2end/small_input.txt
```
Программа выводит графическое представление красно-чёрного дерева с помощью [!Graphviz](/graphviz/tree_graph.png). 

# Тесты

## Запуск всех тестов через CTest

Проект содержит unit-тесты (GoogleTest) и end2end тесты.

1. Создайте тесты:
```bash
cmake --build build 
```

2. Запустите тестовый двоичный файл:
```bash
cd build
ctest --output-on-failure
```
Вы увидите 3 теста:
- `unit_all` — набор GoogleTest, проверяющих инварианты КЧ-дерева и корректность основных операций

- `e2e_small` — подаём входной файл, сравниваем stdout с эталоном

- `e2e_big_runs` - прогон на большом входе, проверка, что программа корректно отрабатывает и укладывается по времени


## Запуск unit-теста отдельно

```bash
cmake --build build --target rbtree_unit_tests
build/tests/rbtree_unit_tests
```

### Пример графического представления дерева

![dump](/graphviz/tree_graph.png)


Так же если вам интересно узнать кто же все-так быстрее 
<details>

## Сравнение производительности

Для оценки эффективности реализованного дерева был добавлен режим замера времени, в котором программа выполняет все операции дважды:
один раз с использованием собственного `RBtree`, и второй — со стандартным контейнером `std::set`

Для обоих структур измеряется время выполнения вставок `k` и диапазонных запросов `q a b `

Для сравнения написан скрипт на [Python](scripts/query_gen.py), который генерирует последовательности запросов. Этот скрипт принимает несколько аргументов: количество элементов в дереве и имя выходного файла, в который будут записаны запросы. Например, если первый аргумент равен 10, будут сгенерированы 10 вставочных k-запросов для чисел от 0 до 9 включительно и q-запросы на расстояние для каждой пары элементов (кроме пар, в которых первый и последний элементы равны).



Скрипт не генерирует случайную последовательность запросов. Методы генерации последовательности запросов были выбраны таким образом, чтобы наиболее наглядно продемонстрировать разницу между std::distance и RBtree::distance.

Результаты сравнения:

| N (number of elements) | **RBtREE::rbtree** time, $\mu s$ | **std::set** time, $\mu s$ |
|:----------------------:|-----------------------------:|----------------------:|
| 200   | 7 970    | 6 579 |
| 500   | 70 295   | 69 596 |
| 1 000 | 616 703  | 605 180 |
| 1 500 | 2 018 082 | 1 851 015 |
| 2 000 | 4 839 870 | 5 251 569 |
| 2 500 | 9 391 764 | 10 334 201 |
| 3 000 | 16 104 091 | 17 051 500 |
| 3 500 | 25 133 257 | 26 463 580 |
| 5 000 | 75 006 971 | 79 750 321 |
</details>
