#pragma once

#include <fstream>
#include <sstream>
#include <cstdlib>
#include <filesystem>
#include <string>
#include <iostream>

#include "red_black_tree.hpp"

namespace Tree
{

template <typename KeyT>
class Print_tree 
{
    // проверка наличия команды в path (POSIX: command -v, Windows: where)
    static bool command_exists(const std::string& cmd)
    {
    #ifdef _WIN32
        std::string check = "where " + cmd + " >nul 2>nul";
    #else
        std::string check = "command -v " + cmd + " >/dev/null 2>&1";
    #endif
        int rc = std::system(check.c_str());
        return rc == 0;
    }

    // pисует один узел (для Graphviz .dot)
    void emit_node_(const Tree::Node<KeyT>& node,
                    std::ofstream& out,
                    bool is_root) const 
    {
        const char* fill = is_root ? "#5A5A5A"
                                   : (node.color == Tree::Color::red ? "#D85C5C" : "#BDBDBD");
        const char* font = is_root ? "white" : "black";

        std::ostringstream parent_ss, left_ss, right_ss;

        if (node.parent_) parent_ss << node.parent_->key_;
        else              parent_ss << "NIL";

        if (node.left_)   left_ss  << node.left_->key_;
        else              left_ss  << "NIL";

        if (node.right_)  right_ss << node.right_->key_;
        else              right_ss << "NIL";

        out << node.key_
            << " [shape=Mrecord, style=filled, fillcolor=\"" << fill
            << "\", fontcolor=\"" << font
            << "\", label=\"{ key: " << node.key_
            << " | parent: " << parent_ss.str()
            << " | { L: " << left_ss.str() << " | R: " << right_ss.str()
            << " } }\" ];\n";
    }

    // рекурсивный обход и соединение узлов
    void print_(const Tree::Node<KeyT>& node, std::ofstream& out, std::size_t& nil_counter, bool is_root = false) const 
    {
        emit_node_(node, out, is_root);

        if (node.left_) 
        {
            out << node.key_ << " -> " << node.left_->key_ << ";\n";
            print_(*node.left_, out, nil_counter, false);
        } 
        else 
        {
            const std::string nil_id = "nilL_" + std::to_string(nil_counter++);
            out << nil_id
                << " [shape=box, style=filled, fillcolor=\"#BDBDBD\", label=\"NULL\"];\n";
            out << node.key_ << " -> " << nil_id << ";\n";
        }

        if (node.right_) 
        {
            out << node.key_ << " -> " << node.right_->key_ << ";\n";
            print_(*node.right_, out, nil_counter, false);
        } 
        else 
        {
            std::string nil_id = "nilR_" + std::to_string(nil_counter++);
            out << nil_id
                << " [shape=box, style=filled, fillcolor=\"#BDBDBD\", label=\"NULL\"];\n";
            out << node.key_ << " -> " << nil_id << ";\n";
        }
    }

public:
    void dump(const Tree::Red_black_tree<KeyT>& rb_tree,
              const std::string& dot_path = "graphviz/file_graph.dot",
              const std::string& png_path = "graphviz/tree_graph.png",
              bool auto_open = true) const
    {
        const auto dir = std::filesystem::path(dot_path).parent_path();

        if (!dir.empty()) 
            std::filesystem::create_directories(dir);

        std::ofstream out(dot_path);
        if (!out) {
            std::cerr << "[ERROR] can't open " << dot_path << "\n";
            return;
        }

        out << "digraph RB_tree {\n"
               "label = < Red-black tree >;\n"
               "bgcolor = \"#BAF0EC\";\n"
               "rankdir=TB;\n"
               "node  [shape=record, style=filled];\n"
               "edge  [color=black, arrowsize=0.8];\n";

        if (auto root = rb_tree.get_root()) 
        {
            std::size_t nil_counter = 0; 
            print_(*root, out, nil_counter, true);
        } 
        else 
        {
            out << "empty_tree [label=\"EMPTY TREE\", shape=box, style=filled, fillcolor=\"#CCCCCC\"];\n";
        }

        out << "}\n";
        out.close();

        if (!command_exists("dot")) 
        {
            std::cerr << "INFO: dot saved to: " << dot_path << "\n"
                      << "WARN: graphviz 'dot' not found in PATH.\n"
                      << "       PNG is not generated by the program.\n"
                      << "       You can render it later via Python script (see scripts/render_dot.py).\n";
        }
        else 
        {
            std::cerr << "INFO: dot saved to: " << dot_path << "\n"
                      << "INFO: graphviz 'dot' is available. To render PNG via Python:\n"
                      << "       python3 scripts/render_dot.py \"" << dot_path << "\" graphviz/tree.png\n";
        }

        // Генерация png
    //     if (!command_exists("dot"))
    //     {
    //         std::cerr << "[WARN] Graphviz (dot) not found in PATH. PNG won't be generated.\n"
    //                   << "       You can install graphviz and run:\n"
    //                   << "       dot -Tpng \"" << dot_path << "\" -o \"" << png_path << "\"\n";
    //         return;
    //     }

    //     {
    //         std::string cmd = "dot -Tpng \"" + dot_path + "\" -o \"" + png_path + "\"";
    //         (void)std::system(cmd.c_str());
    //     }

    //     if (!auto_open)
    //         return;

    // #ifdef _WIN32
    //     std::string open_cmd = "start \"\" \"" + png_path + "\"";
    //     (void)std::system(open_cmd.c_str());
    // #elif defined(__APPLE__)
    //     if (command_exists("open"))
    //     {
    //         std::string open_cmd = "open \"" + png_path + "\"";
    //         (void)std::system(open_cmd.c_str());
    //     }
    //     else
    //     {
    //         std::cerr << "[WARN] 'open' not found. Please open \"" << png_path << "\" manually.\n";
    //     }
    // #else
    //     if (command_exists("xdg-open"))
    //     {
    //         std::string open_cmd = "xdg-open \"" + png_path + "\"";
    //         (void)std::system(open_cmd.c_str());
    //     }
    //     else
    //     {
    //         std::cerr << "[WARN] 'xdg-open' not found. Please open \"" << png_path << "\" manually.\n";
    //     }
    // #endif
    }
};

} // namespace Tree
