# RED-BLACK_TREE

Проект создан в рамках курса по $C$++ Константина Владимирова.
Задача состояла в том, чтобы реализовать класс, представляющий собой сбалансированное дерево, которое находит k-й наименьший элемент (K-query) и количество элементов, меньшее заданного (N-query), за `O(log n)` времени.

## Опискание

Красно-чёрное дерево — двоичное дерево поиска, у которого каждому узлу сопоставлен дополнительный атрибут - цвет и для которого выполняются следубщие свойства:
- Каждый узел промаркирован красным или черным цветом. 
- Корень и конечные узлы (листья) дерева - черные. 
- У красного узла родительский узел - черный.
- Все простые пути из любого узла x до листьев содержат одинаковое количество черных узлов.

Все листья дерева являются фиктивными и не содеражат данных, но относятся к дереву и являются чёрными. 



# Описание проекта 

## Ввод
- Программа получает ключи и запросы от стандартных входных данных.
- Каждый запрос состоит из пары ключей (два возможных значения).
- Запрос действителен только в том случае, если второй ключ больше, чем первый; в противном случае результат для этого запроса равен нулю.


## Вывод
Для каждого запроса программа должна учитывать количество ключей в дереве, которые лежат строго в левой и правой границах запроса (включительно).

### Пример
```bash
k 10
k 20
k 15
q 10 20
```

Вывод
```bash
3
```

# Создание проекта


## Режимы работы


| Режим | Что собрать / какие флаги | Как запустить | Примечания |
|---|---|---|---|
| **Обычный** | `cmake -S . -B build -DSET_MODE_ENABLED=OFF` | `./build/rb_tree < tests/end2end/small_input.txt` | Только наше дерево, печатает ответы. |
| **Проверка ответов** | `cmake -S . -B build -DSET_MODE_ENABLED=ON` | `./build/rb_tree < tests/end2end/small_input.txt` | Параллельно считает через `std::set`, расхождения выводит в `stderr`. |
| **Бенчмарк** | (без флагов) | `./build/rb_tree_bench < tests/end2end/big_input.txt 1>/dev/null` | Отдельный бинарь. Усреднение по батчам, настраивается `--bench-batch=N` (по умолчанию 2000). |
| **Графвиз-дамп** | см. ниже | см. ниже | Дамп включается компиляторным дефайном `CUSTOM_MODE_DEBUG`. |

-----------------------------------------

Создаются два бинарных файла 
- `rb_tree` читает команды из stdin (k X, q A B), отвечает на запросы.
Если собрать с флагом -DSET_MODE_ENABLED=ON, дополнительно проверяет ответы через `std::set` и пишет расхождения в stderr
- `rb_tree_bench` читает тот же формат входа, меряет время вставок/запросов для твоего дерева и (при SET_MODE_ENABLED для этого бинарника — он уже включён в CMake) для `std::set`. Усредняет по батчам.

### Зависимости

- Компилятор, совместимый с C++17.
- CMake (минимальная версия 3.11).
- Установлен Graphviz (команда `dot`).


### Запуск проекта 

```bash
git clone https://github.com/MaxGud10/RBtree
cd RBtree
mkdir build
```

 - `Основной режимy`
 ```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DSET_MODE_ENABLED=OFF
cmake --build build
./build/rb_tree < tests/end2end/small_input.txt

```

- `Режим проверки с std::set`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DSET_MODE_ENABLED=ON
cmake --build build
./build/rb_tree < tests/end2end/small_input.txt

```
При несовпадении результатов дерево постороенное через `set` выведет отладочную информацию в `stderr`.


- `Режим замера времени`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
./build/rb_tree_bench < tests/end2end/big_input.txt 1>/dev/null
# Дополнительно можно задать размер батча:
# ./build/rb_tree_bench --bench-batch=5000 < tests/end2end/big_input.txt 1>/dev/null
```

- `Debug`

При сборке в Debug (`-DCMAKE_BUILD_TYPE=Debug`) бинарь rb_tree автоматически создает `.dot`- файл с описанием деререва, который можно потом визуализировать через `Graphviz`.

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DSET_MODE_ENABLED=ON
cmake --build build
./build/rb_tree --gv-file=graphviz/file_graph.dot < tests/end2end/small_input.txt
```

Программа создает текстовое представление `dot` вашего красно-чёрного дерева с помощью [!Graphviz](/graphviz/file_graph.dot).

По умолчанию создаётся файл
`graphviz/file_graph.dot`

`Пользовательские имена файлов `

Вы можете свои имена прямо при запуске:

| Аргумент | Что делает | Пример |
|-----------|-------------|--------|
| `--gv-file=<путь>` | Указывает полное имя `.dot`-файла. | `./rb_tree --gv-file=my_tree.dot < input.txt` |
| `--gv-prefix=<префикс>` | Задаёт префикс, к которому добавится `_tree.dot`. | `./rb_tree --gv-prefix=run01 < input.txt` создаст `run01_tree.dot` |

<details>
<summary>Примеры:</summary>

### Примеры использования

#### 1. Полный путь к .dot-файлу
```bash
./build/rb_tree --gv-file=graphviz/custom_tree.dot < tests/end2end/small_input.txt
# создаст файл graphviz/custom_tree.dot
```

#### 2. Префикс имени (создаётся автоматически _tree.dot)
```bash
./build/rb_tree --gv-prefix=run01 < tests/end2end/small_input.txt
# создаст run01_tree.dot
```

</details>

Eсли выхотите сгенирировать PNG (графическое представление красно-черного дерева):

```bash
python3 scripts/render_dot.py graphviz/file_graph.dot graphviz/tree.png
```

где `tree.png` - название вашей PNG, a `file_graph.dot` - файл с текстовым представлением дерева

Так же графический dump можно включить в любой конфигурации
<details>
<summary>Расверни</summary>

- `Включить дамп в любой конфигурации (например: Release)`
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DRBTREE_DEBUG_DOT=ON -DSET_MODE_ENABLED=ON
cmake --build build
```

</details>

# Тесты

## Запуск всех тестов через CTest

Проект содержит unit-тесты (GoogleTest) и end2end тесты.

1. Создайте тесты:
```bash
cmake --build build 
```

2. Запустите тестовый двоичный файл:
```bash
cd build
ctest --output-on-failure
``` 
Вы увидите 3 теста:
- `unit_all` — набор GoogleTest, проверяющих инварианты КЧ-дерева и корректность основных операций

- `e2e_small` — подаём входной файл, сравниваем stdout с эталоном

- `e2e_big_runs` - прогон на большом входе, проверка, что программа корректно отрабатывает и укладывается по времени


## Запуск unit-теста отдельно

```bash
cmake --build build --target rbtree_unit_tests
build/tests/rbtree_unit_tests
```

### Пример графического представления дерева

![dump](/graphviz/tree_graph.png)


<!-- Так же если вам интересно узнать кто же все-так быстрее 
<details>

## Сравнение производительности

Для оценки эффективности реализованного дерева был добавлен режим замера времени, в котором программа выполняет все операции дважды:
один раз с использованием собственного `RBtree`, и второй — со стандартным контейнером `std::set`

Для обоих структур измеряется время выполнения вставок `k` и диапазонных запросов `q a b `

Для сравнения написан скрипт на [Python](scripts/query_gen.py), который генерирует последовательности запросов. Этот скрипт принимает несколько аргументов: количество элементов в дереве и имя выходного файла, в который будут записаны запросы. Например, если первый аргумент равен 10, будут сгенерированы 10 вставочных k-запросов для чисел от 0 до 9 включительно и q-запросы на расстояние для каждой пары элементов (кроме пар, в которых первый и последний элементы равны).



Скрипт не генерирует случайную последовательность запросов. Методы генерации последовательности запросов были выбраны таким образом, чтобы наиболее наглядно продемонстрировать разницу между std::distance и RBtree::distance.

Результаты сравнения:

| N (number of elements) | **RBtREE::rbtree** time, $\mu s$ | **std::set** time, $\mu s$ |
|:----------------------:|-----------------------------:|----------------------:|
| 200   | 7 970    | 6 579 |
| 500   | 70 295   | 69 596 |
| 1 000 | 616 703  | 605 180 |
| 1 500 | 2 018 082 | 1 851 015 |
| 2 000 | 4 839 870 | 5 251 569 |
| 2 500 | 9 391 764 | 10 334 201 |
| 3 000 | 16 104 091 | 17 051 500 |
| 3 500 | 25 133 257 | 26 463 580 |
| 5 000 | 75 006 971 | 79 750 321 |
</details> -->
